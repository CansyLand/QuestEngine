# Game Engine and Builder Design Document

## 1. Overview

This document outlines the design for a simple game engine with an integrated game builder and player, running as a Node.js web application on localhost. The system is divided into:

- **Backend (Game Engine):** Manages game logic, state, and flow. It exposes an API for the frontend to interact with (e.g., loading/saving data, advancing game state). The engine is responsible for orchestrating quests, steps, interactions, and state changes (e.g., spawning/clearing items, activating dialogues). It maintains a clear separation from the frontend, issuing commands like "playSound", "spawnItem", "clearNPC", or "changeLocation" via API responses. This allows easy swapping of frontends (e.g., for different environments like web, mobile, or desktop).

- **Frontend Game Builder:** A UI for creating and editing game elements (quests, steps, NPCs, dialogues, items, locations, portals). It uses a 5-column hierarchical layout for navigation and editing.

- **Frontend Game Player:** A minimal tester for game flow, rendering locations as a 16x16 grid with icons for items/NPCs/portals, background image/music, and basic interactions.

The entire system must be implemented in **TypeScript only**, with small, modular files (e.g., one file per major class or component, under 500 lines where possible). Data is persisted as JSON files on disk for easy readability and editing by both the engine and builder.

**Key Principles:**
- **Separation of Concerns:** Engine handles logic and state; frontend handles rendering and user input. Engine commands are imperative (e.g., "spawnItem(itemId)").
- **Simplicity for 1-Day Implementation:** Use Express for the Node server, React (with TypeScript) for frontend (due to columnar UI needs), and Node's `fs` module for persistence. Avoid complex libraries; stick to built-ins and essentials (e.g., no external DB, just JSON files).
- **Waterproof Logic:** All edge cases handled (e.g., no quests, invalid states). No logical fallacies (e.g., clear state transitions, idempotent operations).
- **Extensibility:** Items, NPCs, portals, and dialogues can trigger quests or step advancements via configurable actions.

**Tech Stack:**
- Backend: Node.js with Express (for API and serving static frontend files).
- Frontend: React with TypeScript (for builder and player UIs).
- Persistence: JSON files (e.g., `game.json` containing all data, or split into `quests.json`, `npcs.json`, etc., for modularity—recommend split for easier management).
- No additional packages beyond: `express`, `react`, `react-dom`, `@types/*` for TS. Use `ts-node` for running.

**Setup:**
- Run on localhost:3000 (e.g., `/builder` for builder, `/player` for player).
- API base: `/api`.

## 2. Architecture

- **File Structure (Keep Small and Modular):**
  ```
  project/
├── gameEditor/
│   ├── gameEditor/
│   │   ├── backend/
│   │   │   ├── engine.ts          // Core engine class (game state, logic).
│   │   │   ├── models.ts         // Data interfaces (Game, Quest, NPC, etc.).
│   │   │   ├── persistence.ts    // Load/save JSON functions.
│   │   │   ├── api.ts            // Express routes for API.
│   │   │   └── server.ts         // Main Express server.
│   │   ├── frontend/
│   │   │   ├── builder/
│   │   │   │   ├── Builder.tsx   // Main builder component.
│   │   │   │   ├── EntityPanel.tsx // Reusable panel for entity types.
│   │   │   │   ├── EditModal.tsx // Modal for editing elements.
│   │   │   │   ├── ActionBuilder.tsx // Component for building action lists.
│   │   │   │   └── index.tsx     // Entry for builder.
│   │   │   ├── player/
│   │   │   │   ├── Player.tsx    // Main player component.
│   │   │   │   ├── Grid.tsx      // 16x16 grid renderer.
│   │   │   │   ├── DialoguePanel.tsx // NPC interaction panel.
│   │   │   │   └── index.tsx     // Entry for player.
│   │   │   └── shared/
│   │   │       └── utils.ts      // Shared TS utils (e.g., API fetch wrappers).
│   ├── data/                     // JSON files (e.g., quests.json, npcs.json).
│   ├── public/                   // Static assets (images, audio).
│   ├── tsconfig.json
└── package.json                  // React in devDependencies, exists for Decentraland
  ```

- **Data Flow:**
  - Builder: Loads data via API, edits in-memory, saves via API (backend writes JSON).
  - Player: Loads data via API, sends interactions (e.g., "clickItem(itemId)"), receives commands (e.g., "playSound(audioUrl)", "clearItem(itemId)").
  - Engine: Loads JSON on init, manages state, processes actions.

- **Persistence Strategy:** Use separate JSON files for modularity (`locations.json`, `quests.json`, `npcs.json`, `items.json`, `dialogues.json`). A top-level `game.json` references them (e.g., `{ "locationsFile": "locations.json", ... }`). Backend loads all on startup, merges into in-memory Game object. Saves overwrite files atomically (write temp, rename).

## 3. Data Models

Refined from provided schemas for consistency, completeness, and TypeScript compatibility. All IDs are strings (e.g., UUIDs generated on creation). Use enums for states. Add triggers/actions for extensibility.

```typescript
// src/backend/models.ts

export enum InteractiveMode {
  NotInteractive = 'notInteractive',
  Grabbable = 'grabbable',
  Interactive = 'interactive',
}

export enum ActionType {
  PlaySound = 'playSound',
  AddToInventory = 'addToInventory',
  SpawnEntity = 'spawnEntity',  // Entity: item/npc/portal ID
  ClearEntity = 'clearEntity',
  ActivateQuest = 'activateQuest',  // Quest ID
  AdvanceStep = 'advanceStep',      // In current quest
  ChangeLocation = 'changeLocation',// Location ID
}

export interface Action {
  type: ActionType;
  params: Record<string, any>;  // e.g., { soundUrl: string } or { entityId: string }
}

export interface Dialog {
  id: string;
  text: string;
  isQuestion: boolean;
  buttons?: Button[];  // If isQuestion
  isEndOfDialog: boolean;
  onNext?: Action[];   // Triggers on proceeding (e.g., after button or next)
}

export interface Button {
  label: string;
  goToDialogId: string;  // ID in same sequence
  onClick?: Action[];    // Additional triggers
}

export interface DialogueSequence {
  id: string;
  name: string;
  dialogs: Dialog[];  // Sequential, buttons branch
}

export interface NPC {
  id: string;
  name: string;
  portrait: string;  // URL
  dialogueSequences: DialogueSequence[];  // All possible sequences
  activeSequenceId?: string;  // Set by steps (runtime state)
  spawned: boolean;
  cleared: boolean;  // Use "cleared" instead of "destroyed/removed"
  onInteract?: Action[];  // Optional triggers on talk start/end
}

export interface Item {
  id: string;
  name: string;
  image: string;  // Icon URL
  audio?: string; // General audio
  audioOnInteraction?: string;
  audioOnGrab?: string;
  spawned: boolean;
  cleared: boolean;
  interactive: InteractiveMode;
  onInteract: Action[];  // e.g., [{ type: 'addToInventory', params: { count: 1 } }, { type: 'playSound', params: { url: 'grab.mp3' } }]
}

export interface Portal extends Omit<Item, 'onInteract'> {
  destinationLocationId: string;
  onInteract: Action[];  // Must include ChangeLocation
}

export interface Location {
  id: string;
  backgroundMusic: string;  // URL
  backgroundImage: string;  // URL
  items: Item[];  // Initial list
  npcs: NPC[];
  portals: Portal[];
}

export interface QuestStep {
  id: string;
  name: string;
  objective: string;  // e.g., "Talk to NPC" or "Collect 3 crystals"
  objectiveType: 'talkTo' | 'collect' | 'interact' | 'custom';  // For auto-advance logic
  objectiveParams: Record<string, any>;  // e.g., { npcId: string } or { itemName: 'crystal', count: 3 }
  onStart: Action[];  // e.g., set items grabbable, set NPC dialogue
  onComplete: Action[];  // e.g., spawn mushrooms, activateQuest
}

export interface Quest {
  id: string;
  chapter: string;
  title: string;
  description: string;
  order: number;  // For sequencing in chapter
  steps: QuestStep[];
  activeStepId?: string;  // Runtime
  completed: boolean;     // Runtime
}

export interface Game {
  locations: Location[];
  quests: Quest[];
  items: Item[];  // Global master list? No—items are per location, but steps can reference by ID
  npcs: NPC[];    // Global master, assigned to locations
  // Runtime state
  currentLocationId: string;
  activeQuests: string[];  // Quest IDs
  inventory: Record<string, number>;  // e.g., { crystal: 3 }
}

// Note: Items/NPCs/Portals reference by ID across files if split.
```

- **Notes on Models:**
  - **Cleared vs. Removed:** Use "cleared" boolean to hide/remove visually/logically without deleting data.
  - **Triggers/Actions:** Generalized for flexibility. Engine executes actions on events (e.g., dialog end, item interact).
  - **Inventory:** Count-based map (e.g., for collecting multiples like crystals).
  - **Dialogue:** Sequences are named; steps set activeSequenceId on NPCs.
  - **Objectives:** Typed for engine to check completion (e.g., talkTo: after dialogue ends; collect: inventory check).
  - **Runtime vs. Persistent:** Runtime fields (e.g., activeStepId) not saved; reloaded fresh on player start.

## 4. Game Builder Frontend

Instead, the best approach for ease of use, considering everything (independent element definition, connections via actions/triggers, and dropdown selectability), is a tabbed interface with separate panels for each entity type. This allows users to define elements separately first (e.g., create all NPCs and items upfront), then link them intuitively via dropdowns in forms. It's straightforward, familiar (like admin panels or CMS), and ensures all predefined elements are selectable via dropdowns (populated from loaded data). For connections (e.g., actions in steps), use a dynamic list builder with add/remove buttons and dropdowns—visual but not full node-graph. This keeps it simple, professional, and user-friendly: no hunting through hierarchies, quick access, and logical flow (define basics first, then compose quests).


UI Layout: Top tabs for entity types: "Locations", "Quests", "NPCs", "Items", "Portals", "Dialogues". Each tab shows a list of entities (cards or table rows) with "Create New" button. Selecting an entity opens an inline editor or modal for details.

Locations Tab: List of locations. Edit form: inputs for backgroundMusic/image; searchable dropdowns to add existing items/NPCs/portals (from global lists).
Quests Tab: List of quests (grouped by chapter in accordions). Edit quest: chapter, title, description, order. Sub-list for steps; each step edit: name, objective, objectiveType (dropdown), params (dynamic fields based on type, e.g., count for 'collect'). For onStart/onComplete: ActionBuilder component—a list where user clicks "Add Action", selects ActionType from dropdown, then fills params (e.g., dropdown for entityId from predefined NPCs/items).
NPCs Tab: List of NPCs. Edit: name, portrait; sub-list for dialogueSequences (add/edit sequences, then dialogs/buttons with dropdowns for goToDialogId).
Items/Portals Tab: Similar lists. Edit: name, image, audio fields, interactive mode (dropdown), onInteract actions via ActionBuilder.
Dialogues Tab: Standalone for defining sequences (if not tied to NPCs), but primarily managed under NPCs.



Features:

Independent Definition: Define all elements separately (e.g., create items before assigning to locations or steps).
Dropdown Linking: Everywhere a reference is needed (e.g., entityId in actions, npcId in objectives, destinationLocationId in portals), use searchable dropdowns populated from existing entities (e.g., fetch all NPC IDs/names).
Action Builder: Reusable component: Render as a sortable list of action cards. Each card: dropdown for type, then conditional fields/dropdowns for params (e.g., for SpawnEntity, dropdown of entity IDs). Add/remove/reorder buttons.
Copy Item/NPC/etc.: Button on entity cards; duplicates with new ID.
Remove: Button on entities; removes from lists (confirm dialog), cascades if referenced (warn user).
Validation: On save, check for dangling references (e.g., action entityId exists).
Chapters Handling: Derived from quests; in Quests tab, auto-group, or allow creating chapters as top-level for organization.
Save/Load: Global buttons to call API (/api/save, /api/load). Auto-load on mount, auto-refresh dropdowns on changes.
Ease of Use Enhancements: Search filters in lists, drag-drop for reordering (if time; use react-sortable), tooltips for fields.



Implementation Notes: Use React Tabs (or simple state-based). EntityPanel.tsx reusable for lists/forms. ActionBuilder.tsx handles dynamic forms (use switch on type for rendering). Keeps files small; no extra libs needed. This is more intuitive than columns (no deep navigation) or nodes (no learning curve), and ensures everything is considered by compartmentalizing.

## 5. Game Player Frontend

- **Minimal Implementation:**
  - **Layout:** Full-screen background image (from current location). Audio player for background music (HTML5 <audio>).
  - **Grid:** 16x16 CSS grid (Grid.tsx). Place items/NPCs/portals icons randomly using seed (e.g., seedrandom lib? Or simple hash-based placement). Positions fixed per seed/location.
  - **Interactions:**
    - Click Item/Portal: If touchable, play audioOnInteraction. If grabbable, play audioOnGrab, add to inventory, clear (set cleared=true, remove from grid).
    - Click NPC: Open DialoguePanel.tsx (right sidebar) with portrait, current text, buttons. Click button: goToDialogId, execute onClick actions, send to API for processing.
    - Portal: On interact, execute ChangeLocation (API call to change, receive new commands).
  - **Inventory:** Display as list in corner (e.g., "Crystals: 3").
  - **Quest Progress:** Implicit via engine; frontend receives commands on changes (e.g., after advanceStep).

- **API Integration:** On interaction, POST to /api/interact { type: 'clickItem', params: { id: string } }. Receive { commands: Command[] } (e.g., { type: 'playSound', params: { url: string } }). Execute (e.g., new Audio(url).play()).

- **Implementation Notes:** Start with initial location/quests via /api/start. Handle commands in utils.ts.

## 6. Game Engine Backend

- **Core Logic (engine.ts):**
  - Load JSON into Game object.
  - Methods:
    - `start()`: Set initial location, activate starting quests.
    - `processInteraction(type: string, params: any)`: e.g., clickItem -> check interactive, execute onInteract actions, check objectives.
    - `advanceStep(questId: string)`: Execute onComplete, set next activeStepId, execute onStart of next.
    - `checkObjective(step: QuestStep)`: Based on type (e.g., collect: inventory[name] >= count -> auto-advance).
    - `changeLocation(id: string)`: Clear current (set cleared=true for items/npcs), spawn new (spawned=true), update bg/image/music.
  - Return commands array for frontend.

- **API (api.ts):**
  - GET /api/load: Return full Game JSON.
  - POST /api/save: Accept Game JSON, write to files.
  - POST /api/start: Init engine, return initial commands.
  - POST /api/interact: Process, return commands.

- **Persistence (persistence.ts):** fs.readFileSync/writeFileSync for JSON. Handle splits (e.g., write quests to quests.json).

## 7. API Between Frontend and Backend

- **Commands from Engine to Frontend:** JSON array of { type: string, params: Record<string, any> } (e.g., playSound, spawnItem(id), clearNPC(id), changeBackground(imageUrl), etc.).
- **Requests from Frontend:** POST with { type: string, params: any } (e.g., clickItem(id)).
- **Error Handling:** Always return { success: bool, error?: string, commands?: Command[] }.


## 8. Additions
- All Assets will be urls  images and mp3
- in front show progress of quests and item interactions.like a log in games



This design is complete, logical, and implementable in 1 day by an experienced dev (focus on core, add polish if time). If clarifications needed, provide details!