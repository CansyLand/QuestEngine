# Quest Engine for Decentraland

The Quest Engine bridges your React game editor with Decentraland scenes, allowing you to use the same JSON game definitions in both environments.

## Architecture Overview

```
React Game Editor (gameEditor/)
    ├── backend/engine.ts (processes interactions → commands)
    └── frontend/ (renders grid, handles UI)

Decentraland Quest Engine (src/questEngine/)
    ├── QuestEngine.ts (adapted engine logic)
    ├── SceneController.ts (executes commands in Decentraland)
    ├── EntityManager.ts (manages GLTF visibility & colliders)
    ├── LocationAdapter.ts (handles location transitions)
    └── entityMappings.ts (JSON ID → Decentraland name mapping)
```

## Key Differences from React Version

### Entity Management

- **React**: Commands like `spawnEntity`, `clearEntity` create/remove DOM elements
- **Decentraland**: Commands like `setEntityVisibility`, `addGltfComponent` manage GLTF components and colliders

### Location Transitions

- **React**: Sends grid entities to frontend for rendering
- **Decentraland**: Manages individual entity visibility without Creator Hub restrictions

### Persistence

- **React**: Uses localStorage for testing
- **Decentraland**: Loads from JSON files (no save capability - stateless)

## Usage

### Basic Setup

```typescript
import { createQuestEngine } from './src/questEngine'
import { AudioSystem } from './src/gameEngine/AudioSystem'

// In your Decentraland scene
const audioSystem = new AudioSystem()

async function initializeGame() {
  const questEngine = await createQuestEngine(audioSystem, undefined, true) // debug mode

  // Start the game
  const commands = questEngine.start()
  questEngine.executeCommands(commands)
}

// Initialize the game
initializeGame()
```

### Handling Player Interactions

```typescript
// When player clicks an item/NPC/portal
const commands = questEngine.processInteraction('clickItem', { id: 'crystal_1' })
questEngine.executeCommands(commands)
```

### Entity State Management

The engine manages three entity states:

- **World**: `visible: true` + interactive collider + GLTF component
- **Inventory**: `visible: false` + no collider (preserves GLTF)
- **Void**: `visible: false` + no collider (preserves GLTF for Creator Hub stability)

### Location Transitions

```typescript
// Location changes are handled automatically by the engine
// The LocationAdapter manages entity visibility without bulk operations
const commands = questEngine.changeLocation('cave_location_id')
questEngine.executeCommands(commands)
```

## Entity Mapping

Entities are mapped from JSON IDs to Decentraland entity names:

```typescript
// src/questEngine/entityMappings.ts
export const ENTITY_MAPPINGS = [
  { jsonId: 'crystal', decentralandName: EntityNames.Item_Crystal_1 },
  { jsonId: 'persephone', decentralandName: EntityNames.NPC_Persephone }
  // ...
]
```

### Adding New Entity Mappings

1. Add entity to `entity-names.js` (generated by Creator Hub)
2. Add mapping in `entityMappings.ts`
3. Ensure entity exists in Decentraland scene

## Command Types

The quest engine uses Decentraland-specific commands:

```typescript
enum QuestCommandType {
  // Entity management
  SetEntityVisibility = 'setEntityVisibility',
  SetEntityCollider = 'setEntityCollider',
  AddGltfComponent = 'addGltfComponent',
  RemoveGltfComponent = 'removeGltfComponent',

  // Audio & UI
  PlaySound = 'playSound',
  PlayBackgroundMusic = 'playBackgroundMusic',
  ShowDialogue = 'showDialogue',
  ShowNotification = 'showNotification',

  // Quest management
  QuestActivated = 'questActivated',
  QuestCompleted = 'questCompleted',

  // Location
  ChangeLocation = 'changeLocation',

  // Inventory
  UpdateInventory = 'updateInventory',

  // Debug
  Log = 'log'
}
```

## Integration with Existing Systems

### Audio System

The quest engine reuses your existing `AudioSystem`:

- `playSoundEffect()` for sound effects
- `playBackgroundMusic()` for ambient audio

### NPC Dialogues

The quest engine integrates with your existing NPC toolkit:

- Triggers dialogue sequences
- Maintains quest-aware NPC interactions

### Cutscenes

Your existing `cutscenes.ts` can be used directly:

```typescript
import { playCutsceneById } from '../gameEngine/cutscenes'
```

## Limitations & Considerations

### Creator Hub Constraints

- Cannot `engine.addEntity()` or `engine.removeEntity()`
- Must manage entity visibility through GLTF components
- Triangle limits require GLTF removal for performance

### Stateless Sessions

- **No persistence**: Game state resets each session (Decentraland limitation)
- **Fresh start**: Players begin with empty inventory and inactive quests
- **Configuration only**: JSON files define initial game setup, not saved progress

### Entity Discovery

The `EntityManager.findEntityByName()` method uses Decentraland's native `engine.getEntityByName()` function, which automatically finds entities by their assigned names from Creator Hub. This provides direct access to scene entities without custom components or registries.

### Performance

- Location transitions manage individual entities (not bulk operations)
- GLTF components are preserved when hiding entities (for Creator Hub stability)
- Consider batching commands for better performance

## Development Workflow

1. **Test in React**: Use `gameEditor` for rapid iteration
2. **Verify Logic**: Ensure command generation matches between versions
3. **Adapt Commands**: Convert React commands to Decentraland actions
4. **Test in Decentraland**: Validate entity state management
5. **Optimize**: Profile performance and adjust entity management

## Data Generation Script

The quest engine uses embedded TypeScript constants instead of loading JSON files at runtime. The `generate-data.js` script converts JSON data files into TypeScript constants.

### Usage

```bash
# Generate embedded data from JSON files
npm run generate-data

# Or run directly
node scripts/generate-data.js
```

### What it does

- Reads JSON files from `src/questEngine/data/`:
  - `locations.json` → `EMBEDDED_LOCATIONS`
  - `quests.json` → `EMBEDDED_QUESTS`
  - `npcs.json` → `EMBEDDED_NPCS`
  - `items.json` → `EMBEDDED_ITEMS`
  - `portals.json` → `EMBEDDED_PORTALS`
  - `dialogues.json` → `EMBEDDED_DIALOGUES`

- Generates `src/questEngine/data.ts` with embedded constants
- Ensures all game data is available at runtime without external file loading

### Why embedded data?

- **Reliability**: Decentraland scenes may have issues loading external JSON files
- **Performance**: No runtime file I/O operations
- **Type safety**: TypeScript constants provide better IDE support
- **Bundle size**: Data is included in the compiled scene

### Workflow

1. Edit JSON files in `src/questEngine/data/`
2. Run `npm run generate-data` to update embedded constants
3. The quest engine will use the updated data on next scene load

## File Structure

```
src/questEngine/
├── QuestEngine.ts         # Main game logic (adapted from gameEditor/engine.ts)
├── SceneController.ts     # Command executor for Decentraland
├── EntityManager.ts       # GLTF visibility & collider management
├── LocationAdapter.ts     # Location transition management
├── QuestPersistence.ts    # Save/load game state
├── entityMappings.ts      # JSON ID → Decentraland name mapping
├── data.ts               # Embedded game data constants (generated)
├── data/                 # Source JSON files
│   ├── locations.json
│   ├── quests.json
│   ├── npcs.json
│   ├── items.json
│   ├── portals.json
│   └── dialogues.json
├── types.ts              # TypeScript definitions
├── index.ts              # Factory functions and exports
└── docs/README.md        # This file

scripts/
└── generate-data.js      # Data generation script
```

## Next Steps

1. Customize `EntityManager.findEntityByName()` for your scene's entity naming
2. Integrate with your existing NPC dialogue system
3. Add notification system for quest feedback
4. Implement Decentraland-specific persistence
5. Test with your full game data
